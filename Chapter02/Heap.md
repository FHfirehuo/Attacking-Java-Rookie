# 堆

堆就是用**数组实现的二叉树**，所有它没有使用父指针或者子指针。
堆根据**堆属性**来排序，**堆属性**决定了树中节点的位置。

堆是利用完全二叉树的结构来维护一组数据，然后进行相关操作，
一般的操作进行一次的时间复杂度在O(1)~O(logn)之间。

### 堆的常用方法：

* 构建优先队列
* 支持堆排序
* 快速找出一个集合中的最小值（或者最大值）
* 在朋友面前装逼

### 堆和普通树的区别

堆并不能取代二叉搜索树，它们之间有相似之处也有一些不同。我们来看一下两者的主要差别：

* 节点的顺序: 在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。
* 内存占用: 普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额为是我内存。堆仅仅使用一个数据来村塾数组，且不使用指针。
* 平衡: 二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到O(log n)。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证O(log n) 的性能。
* 搜索: 在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。

### 来自数组的树

用数组来实现树相关的数据结构也许看起来有点古怪，但是它在时间和空间山都是很高效的。

我们准备将上面的例子中的树这样存储：

    [ 10, 7, 2, 5, 1 ]
   
就这多！我们除了一个简单的数组以外，不需要任何额外的空间。

如果我们不允许使用指针，那么我们怎么知道哪一个节点是父节点，哪一个节点是它的子节点呢？问得好！节点在数组中的位置index 和它的父节点已经子节点的索引之间有一个映射关系。

如果 i 是节点的索引，那么下面的公式就给出了它的父节点和子节点在数组中的位置：

    parent(i) = floor((i - 1)/2)
    left(i)   = 2i + 1
    right(i)  = 2i + 2

注意 right(i) 就是简单的 left(i) + 1。左右节点总是处于相邻的位置。
