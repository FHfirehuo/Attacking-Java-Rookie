# 代理模式

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。

在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。

代理就是中介，中间人。法律上也有代理，比如代理律师之类，委托人将自己的一部分权限委托给代理者，
代理者就拥有被代理者（委托人）的部分权限，并且可以以被代理人的名义来实行这些权限，
此时代理者与委托人等同，当然代理人也可以在实行权限时配合自己的能力来进行，当然不能超出这个权限。

Java中的代理模式类似于上面的代理，我们也是为一个类（委托类）创建一个代理类，来代表它来对外提供功能。　　

### 介绍
* 意图：为其他对象提供一种代理以控制对这个对象的访问。
* 主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
* 何时使用：想在访问一个类时做一些控制。
* 如何解决：增加中间层。
* 实现与被代理类组合。

### 应用实例： 
1. Windows 里面的快捷方式。 
2. 猪八戒去找高翠兰结果是孙悟空变的，可以这样理解：把高翠兰的外貌抽象出来，高翠兰本人和孙悟空都实现了这个接口，猪八戒访问高翠兰的时候看不出来这个是孙悟空，所以说孙悟空是高翠兰代理类。 
3. 买火车票不一定在火车站买，也可以去代售点。 
4. 一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制。 
5. spring aop。

### 优点
1. 职责清晰。
2. 高扩展性。
3. 智能化。

### 缺点
1. 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。
2. 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
3.  增加了代理类与委托类之间的强耦合

### 使用场景

按职责来划分，通常有以下使用场景：
 
1. 远程代理。 
2. 虚拟代理。
3. Copy-on-Write 代理。
4. 保护（Protect or Access）代理。
5. Cache代理。
6. 防火墙（Firewall）代理。 
7. 同步化（Synchronization）代理。
8. 智能引用（Smart Reference）代理。

###### 代理模式场景描述：
1. 当我们想要隐藏某个类时，可以为其提供代理类
2. 当一个类需要对不同的调用者提供不同的调用权限时，可以使用代理类来实现（代理类不一定只有一个，我们可以建立多个代理类来实现，也可以在一个代理类中金进行权限判断来进行不同权限的功能调用）
3. 当我们要扩展某个类的某个功能时，可以使用代理模式，在代理类中进行简单扩展（只针对简单扩展，可在引用委托类的语句之前与之后进行）

### 注意事项

1. 和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
2. 和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

### 代码实现

###### 代理模式很简单，只要记住以下关键点，简单易实现

1. 代理类与委托类实现同一接口
2. 在委托类中实现功能，在代理类的方法中中引用委托类的同名方法
3. 外部类调用委托类某个方法时，直接以接口指向代理类的实例，这正是代理的意义所在：屏蔽。


```java
package designpatterns.proxy;

public interface ZiRanRen {
    void quanLi();
}

```

```java
package designpatterns.proxy;

//委托人：
public class MaYun implements ZiRanRen {

    private void eat() {
        System.out.println("今天吃满汉全席");
    }

    private void drink() {
        System.out.println("今天喝大西洋");
    }

    public void quanLi() {
        System.out.println("我赋予我的代理律师来行使这些权利,此时代理律师全权代理我处理某些事务");
        eat();
    }
}


```


```java
package designpatterns.proxy;

//代理律师
public class LvShi implements ZiRanRen {
    public void quanLi() {
        new MaYun().quanLi();
    }
}

```

```java
package designpatterns.proxy;

public class ProxyMain {

    public static void main(String[] args) {
        ZiRanRen ls = new LvShi();
        ls.quanLi();
    }
}

```

上面是一个很简单的例子，可以看出，我们想对外开放某些功能，
就可以将这些功能在代理类中被引用，如此一来，屏蔽了我们不想外露的功能，
只将我们想开放的功能开放出来。亦即委托类中其实是可以有很多方法的，
很多功能的，我们可以酌情对外开放，代理类犹如一道大门，
将委托类与外部调用者隔绝开来，只将部分功能赋予这个大门，
来代替委托类行使这个功能，哪怕最终还是要牵扯到自身（因为最终还是要调用委托类的对应方法实现）。



