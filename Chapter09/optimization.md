# mysql优化

### 引擎的选择

linux版本mysql5.5后默认引擎是innodb。

MyISAM不支持事务，如果表中绝大多数都只是读查询，可以考虑MyISAM。比如码表。

### 字段的选择

选择合适的字段类型，填充默认值，非空处理

long类型替换datetime，如果可以用int类型替换datetime

### 逆范式

逆范式是指打破范式，通过增加冗余或重复的数据来提高数据库的性能。

多做单边查询,少做联合查询

### 索引

不要过度索引。索引越多，占用空间越大，反而性能变慢；

只对WHERE子句中频繁使用的建立索引；

列独立

左原则 假如业务逻辑上出现: field like '%keywork%'类似查询，需要使用全文索引。

复合索引：一个索引关联多个字段，仅仅针对左边字段有效果。

OR的使用: 必须要保证 OR 两端的条件都存在可以用的索引，该查询才可以使用索引。

索引排序: 如果order by 排序需要的字段上存在索引，则可能使用到索引。

前缀索引: 前缀索引是建立索引关键字一种方案。通常会使用字段的整体作为索引关键字。有时，即使使用字段前部分数据，也可以去识别某些记录。就比如一个班级里，我要找王xx，假如姓王的只有1个人，那么就可以建一个前缀索引，就是王。

全文索引: 全文索引几乎不用，因为它不支持中文


### 加大缓存池

32位系统最大缓存池是4G; 64位系统理论上是


### sql优化

对于并发性的SQL

少用（不用）多表操作（子查询，联合查询），而是将复杂的SQL拆分多次执行。如果查询很原子（很小），会增加查询缓存的利用率。

Limit 的使用

慢查询日志的使用

这里列举出来一些用过的，看到的欢迎大家评论区补充讨论



1、查询尽量避免全表扫描，首先考虑在where、order by字段上添加索引



2、避免在where字段上使用NULL值，所以在设计表时尽量使用NOT NULL约束，有些数据会默认为NULL，可以设置默认值为0或者-1



3、避免在where子句中使用!=或<>操作符，Mysql只对<，<=，=，>，>=，BETWEEN，IN，以及某些时候的LIKE使用索引



4、避免在where中使用OR来连接条件，否则可能导致引擎放弃索引来执行全表扫描，可以使用UNION进行合并查询



select id from t where num = 30 union select id from t where num = 40;



5、尽量避免在where子句中进行函数或者表达式操作



6、最好不要使用select * from t，用具体的字段列表代替"*"，不要返回用不到的任何字段



7、in 和 not in 也要慎用，否则会导致全表扫描，如



select id from t where num IN(1,2,3)如果是连续的值建议使用between and，select id from t where between 1 and 3；



8、select id from t where col like %a%;模糊查询左侧有%会导致全表检索，如果需要全文检索可以使用全文搜索引擎比如es，slor



9、limit offset rows关于分页查询，尽量保证不要出现大的offset，比如limit 10000,10相当于对已查询出来的行数弃掉前10000行后再取10行，完全可以加一些条件过滤一下（完成筛选），而不应该使用limit跳过已查询到的数据。这是一个==offset做无用功==的问题。对应实际工程中，要避免出现大页码的情况，尽量引导用户做条件过滤

### 善于利用Explain 命令

1.1. EXPLAIN
在MySQL中可以使用EXPLAIN查看SQL执行计划。示例：EXPLAIN SELECT * FROM tb_item



 1.2. 结果说明

1.2.1. id
SELECT识别符。这是SELECT查询序列号。这个不重要。

1.2.2. select_type
表示SELECT语句的类型。

有以下几种值：

1、 SIMPLE
表示简单查询，其中不包含连接查询和子查询。

2、 PRIMARY
表示主查询，或者是最外面的查询语句。示例：explain select * from (select * from user_t ) as tmp;



3、 UNION
表示连接查询的第2个或后面的查询语句。示例：EXPLAIN SELECT id from user_t UNION  select id from role;



4、 DEPENDENT UNION
UNION中的第二个或后面的SELECT语句，取决于外面的查询。

5、 UNION RESULT
连接查询的结果。

6、 SUBQUERY
子查询中的第1个SELECT语句。



7、 DEPENDENT SUBQUERY
子查询中的第1个SELECT语句，取决于外面的查询。

8、 DERIVED
SELECT(FROM 子句的子查询)。

1.2.3. table
表示查询的表。

1.2.4. **type（重要）**
表示表的连接类型。

以下的连接类型的顺序是从最佳类型到最差类型：

1、 system
表仅有一行，这是const类型的特列，平时不会出现，这个也可以忽略不计。

2、 const
数据表最多只有一个匹配行，因为只匹配一行数据，所以很快，常用于PRIMARY KEY或者UNIQUE索引的查询，可理解为const是最优化的。



3、 eq_ref
mysql手册是这样说的:"对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY"。eq_ref可以用于使用=比较带索引的列。



4、 ref
查询条件索引既不是UNIQUE也不是PRIMARY KEY的情况。ref可用于=或<或>操作符的带索引的列。



5、 ref_or_null
该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的优化。

上面这五种情况都是很理想的索引使用情况。

6、 index_merge
该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使用的索引的最长的关键元素。

7、 unique_subquery
该类型替换了下面形式的IN子查询的ref: value IN (SELECT primary_key FROM single_table WHERE some_expr)
unique_subquery是一个索引查找函数,可以完全替换子查询,效率更高。

8、 index_subquery
该联接类型类似于unique_subquery。可以替换IN子查询,但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr)

9、 range
只检索给定范围的行,使用一个索引来选择行。



10、 index
该联接类型与ALL相同,除了只有索引树被扫描。这通常比ALL快,因为索引文件通常比数据文件小。

11、 ALL
对于每个来自于先前的表的行组合,进行完整的表扫描。（性能最差）

1.2.5. possible_keys
指出MySQL能使用哪个索引在该表中找到行。

如果该列为NULL，说明没有使用索引，可以对该列创建索引来提高性能。

1.2.6. key
显示MySQL实际决定使用的键(索引)。如果没有选择索引,键是NULL。

可以强制使用索引或者忽略索引：



1.2.7. key_len

显示MySQL决定使用的键长度。如果键是NULL,则长度为NULL。

注意：key_len是确定了MySQL将实际使用的索引长度。

1.2.8. ref
显示使用哪个列或常数与key一起从表中选择行。

1.2.9. rows
显示MySQL认为它执行查询时必须检查的行数。

1.2.10. Extra
该列包含MySQL解决查询的详细信息

Distinct:MySQL发现第1个匹配行后,停止为当前的行组合搜索更多的行。
Not exists:MySQL能够对查询进行LEFT JOIN优化,发现1个匹配LEFT JOIN标准的行后,不再为前面的的行组合在该表内检查更多的行。
range checked for each record (index map: #):MySQL没有发现好的可以使用的索引,但发现如果来自前面的表的列值已知,可能部分索引可以使用。
Using filesort:MySQL需要额外的一次传递,以找出如何按排序顺序检索行。
Using index:从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。
Using temporary:为了解决查询,MySQL需要创建一个临时表来容纳结果。
Using where:WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。
Using sort_union(...), Using union(...), Using intersect(...):这些函数说明如何为index_merge联接类型合并索引扫描。
Using index for group-by:类似于访问表的Using index方式,Using index for group-by表示MySQL发现了一个索引,可以用来查 询GROUP BY或DISTINCT查询的所有列,而不要额外搜索硬盘访问实际的表。

1.3. 使用索引查询需要注意
索引可以提供查询的速度，但并不是使用了带有索引的字段查询都会生效，有些情况下是不生效的，需要注意！

1.3.1. 使用LIKE关键字的查询
在使用LIKE关键字进行查询的查询语句中，如果匹配字符串的第一个字符为“%”，索引不起作用。只有“%”不在第一个位置，索引才会生效。

 



1.3.2. 使用联合索引的查询
MySQL可以为多个字段创建索引，一个索引可以包括16个字段。对于联合索引，只有查询条件中使用了这些字段中第一个字段时，索引才会生效。

 

 

 

1.3.3. 使用OR关键字的查询
查询语句的查询条件中只有OR关键字，且OR前后的两个条件中的列都是索引时，索引才会生效，否则，索引不生效。





 

2. 数据库结构优化
一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。

2.1. 将字段很多的表分解成多个表
对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。

 2.2. 增加中间表

对于需要经常联合查询的表，可以建立中间表以提高查询效率。通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。

2.3. 增加冗余字段
设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。

注意：

冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。


### 分区分表

### 分库分表
